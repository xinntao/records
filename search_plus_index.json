{"./":{"url":"./","title":"简介","keywords":"","body":"记录 Page hosted on GitHub | Page hosted on Gitee码云 GitHub | Gitee码云 记录平时遇到的问题和解决方法. [!TIP] 本仓库在 GitHub 和 Gitee码云 同步. 欢迎在 Github 或 Gitee码云 贡献. [!NOTE] Github pages will automatically update the contents in gh-pages. Gitee pages require manual updates. [!COMMENT|label: Usage] File structure Run the following two commands in the same root folder. git clone git@github.com:xinntao/records.git git clone -b gh-pages git@github.com:xinntao/records.git records-gh-pages The file structure should be like this: - root |--- records |--- records-gh-pages Note that in order to trigger the GitHub actions, we should also copy the .github folder to the records-gh-pages branch for the fist time. Update the master branch in the records folder. Build the gitbook: gitbook build In the records repo, copy the contents in _book folder to records-gh-pages: cp -r _book/* ../records-gh-pages Push to remotes: For records: git push origin master For records-gh-pages: git push origin gh-pages Copyright © Xintao all right reserved，powered by Gitbook修改时间: 2021-10-28 00:50:45 "},"工具软件使用/":{"url":"工具软件使用/","title":"工具软件使用","keywords":"","body":"工具软件使用 记录工具、软件的使用. [!NOTE] 主要是为了方便第二次、第N次能够快速使用. 因此有些地方的说明可能不清楚. Copyright © Xintao all right reserved，powered by Gitbook修改时间: 2021-10-28 00:50:45 "},"工具软件使用/Ubuntu配置PyTorch环境.html":{"url":"工具软件使用/Ubuntu配置PyTorch环境.html","title":"Ubuntu配置PyTorch环境","keywords":"","body":"Ubuntu配置PyTorch环境 可按照以下流程来配置Ubuntu的PyTorch环境. 一些基本命令 查看Ubuntu版本: cat /etc/issue apt更新: sudo apt-get update sudo apt-get upgrade sudo apt-get autoremove --purge 查看已经安装的软件 apt list --installed 搜索软件列表 apt-cache search nvidia 安装Anaconda 或 Miniconda 从 Anaconda 或 Miniconda 下载. wget ... bash ... 安装，不需要sudo权限. conda update --all 检查Nvidia Driver 关于不同版本的cuda对driver最低version的要求, 参见 Nvidia doc - Table 2. 比如: CUDA 10.2.89 >= 440.33 更新driver 首选通过 apt-get 安装 sudo add-apt-repository ppa:graphics-drivers/ppa + sudo apt-get update 搜索列表, 查看是否有需要的版本 apt-cache search nvidia 安装 sudo apt-get install nvidia-440 若apt-get安装失败, 可以通过下载cuda.run文件自带的driver安装, 注意在这之前可能需要: 卸载已有cuda apt list --installed | grep nvidia sudo apt-get --purge autoremove packagename 可能需要禁用lightdm服务 sudo service lightdm stop 若仍有问题, 请参考安装指南. 添加配置, 提高性能 These commands can be added to /etc/rc.local for executing at system boot. sudo nvidia-smi -pm 1 sudo nvidia-smi -e 0 最终确认nvidia driver是否成功: nvidia-smi 安装cuda 如果不需要编译带.cu的源文件，可以不需要安装cuda. 因为PyTorch安装的时候，依赖就把runtime的库给安装了. 下载.run文件安装 sudo bash .run. [!NOTE] 若有补丁, sudo bash cuda_9.1.85.1_linux.run. 安装cudnn 安装cudnn只要copy即可: sudo cp -r cuda/lib64/* /usr/local/cuda-10.0/lib64/ sudo cp -r cuda/include/* /usr/local/cuda-10.0/include/ [!TIP] 下载cudnn文件需要先注册 新建Anaconda环境 以 pt15 (pytorch 1.5) 为例: conda create -n pt15 python=3.8 多个cuda版本 如果环境中有多个cuda版本，可以指定conda环境指向的cuda版本. 修改pt15启动环境 activate mkdir -p ~/anaconda3/envs/pt15/etc/conda/activate.d cd ~/anaconda3/envs/pt15/etc/conda/activate.d vim activate.sh 写入以下内容: #!/bin/sh ORIGINAL_LD_LIBRARY_PATH=$LD_LIBRARY_PATH ORIGINAL_PATH=$PATH ORIGINAL_CPATH=$CPATH export LD_LIBRARY_PATH=/usr/local/cuda-10.2/lib64:/usr/local/cuda-10.2/extras/CUPTI/lib64:/lib/nccl/cuda-10.2:$LD_LIBRARY_PATH export PATH=/usr/local/cuda-10.2/bin${PATH:+:${PATH}} export CPATH=/usr/local/cuda-10.2/include${CPATH:+:${CPATH}} # (option) export LD_LIBRARY_PATH=/usr/lib/x86_64-linux-gnu/libnccl.so:$LD_LIBRARY_PATH # you can find the nccl path by ``find /usr -name '*nccl*'`` chmod +x activate.sh deactivate mkdir -p ~/anaconda3/envs/pt15/etc/conda/deactivate.d cd ~/anaconda3/envs/pt15/etc/conda/deactivate.d vim deactivate.sh 写入以下内容: #!/bin/sh export LD_LIBRARY_PATH=$ORIGINAL_LD_LIBRARY_PATH unset ORIGINAL_LD_LIBRARY_PATH export PATH=$ORIGINAL_PATH unset ORIGINAL_PATH export ORIGINAL_CPATH=$ORIGINAL_CPATH unset ORIGINAL_CPATH chmod +x deactivate.sh 安装PyTorch 参见 官网 命令 (要确定安装的PyTorch版本, 以及cuda版本). e.g. conda install pytorch torchvision cudatoolkit=10.2 -c pytorch 验证: python import torch print(torch.__version__) print(torch.version.cuda) print(torch.backends.cudnn.version()) print(torch.cuda.is_available()) Copyright © Xintao all right reserved，powered by Gitbook修改时间: 2021-10-28 00:50:45 "},"工具软件使用/zsh配置.html":{"url":"工具软件使用/zsh配置.html","title":"zsh配置","keywords":"","body":"zsh配置 安装 安装zsh sudo apt-get install zsh 或者已经安装了，查看/usr/bin/zsh 安装oh-my-zsh sh -c \"$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\" 主题 默认的robbyrussell主题就已经很不错啦。 agnoster也还行，就是字符显示有时有问题。修改后, 生效: source ~/.zshrc 插件 zsh-syntax-highlighting git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting Ref: https://github.com/zsh-users/zsh-syntax-highlighting https://github.com/zsh-users/zsh-syntax-highlighting/blob/master/INSTALL.md zsh-completions git clone https://github.com/zsh-users/zsh-completions ${ZSH_CUSTOM:=~/.oh-my-zsh/custom}/plugins/zsh-completions Ref: https://github.com/zsh-users/zsh-completions https://github.com/zsh-users/zsh-completions/blob/master/README.md zsh-autosuggestions git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions Ref: https://github.com/zsh-users/zsh-autosuggestions https://github.com/zsh-users/zsh-autosuggestions/blob/master/INSTALL.md zsh-history-substring-search git clone https://github.com/zsh-users/zsh-history-substring-search ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-history-substring-search Ref: https://github.com/zsh-users/zsh-history-substring-search https://github.com/zsh-users/zsh-history-substring-search/blob/master/README.md 记得要在~/.zshrc更新: (如果没有.zshrc这个文件， 运行一下zsh即可) plugins=(git git-extras yarn zsh-completions zsh-syntax-highlighting zsh-autosuggestions zsh-history-substring-search) autoload -U compinit && compinit 然后执行生效: source ~/.zshrc Copyright © Xintao all right reserved，powered by Gitbook修改时间: 2021-10-28 00:50:45 "},"工具软件使用/tmux使用.html":{"url":"工具软件使用/tmux使用.html","title":"tmux使用","keywords":"","body":"tmux使用 配置 可以把命令写入 ~/.tmux.conf, 这样每次启动tmux就自动执行了。 setw -g mouse on # 启用鼠标 set-option -g allow-rename off # 禁止程序自动修改window名字 set -g history-limit 100000 # 设置显示历史，debug的时候可以看到更多信息 # set scroll speed bind -Tcopy-mode WheelUpPane send -N1 -X scroll-up bind -Tcopy-mode WheelDownPane send -N1 -X scroll-down 常见命令 新建 tmux new -s [name] 修改prefix键, 默认是Ctrl+B set-option -g prefix C-a 其他问题 调节scroll速度, Refbind -Tcopy-mode WheelUpPane send -N1 -X scroll-up bind -Tcopy-mode WheelDownPane send -N1 -X scroll-down Copyright © Xintao all right reserved，powered by Gitbook修改时间: 2021-10-28 00:50:45 "},"工具软件使用/vscode配置.html":{"url":"工具软件使用/vscode配置.html","title":"vscode配置","keywords":"","body":"VSCode配置 代码规范配置 代码格式和静态检查 一般来说有三类： 代码格式: pep8, flake8 静态检查: yapf 自动排序import package: isortpip install flake8 yapf isort vscode修改yapf配置 \"python.formatting.yapfArgs\": [ \"--style\", \"{BASED_ON_STYLE = pep8, BLANK_LINE_BEFORE_NESTED_CLASS_OR_DEF = true, SPLIT_BEFORE_EXPRESSION_AFTER_OPENING_PAREN = true}\" ], 这个修改是全局的，如果不希望全局，则可以在.vscode/settings.json中修改。 保存时自动格式化 \"editor.formatOnSave\": true, \"editor.formatOnPaste\": true, \"[python]\": { \"editor.codeActionsOnSave\": { \"source.organizeImports\": true } } 对于isort需要按保存键两次才可以。 pre-commit hook 提交代码前，在本地执行一些命令。 pip install -U pre-commit pre-commit install # 在当前repo中执行 单元测试 测试单一函数 pytest [xxx.py] -s -k \"function_name\" 其中 -s是输出print内容; -k是只测试包含\"function_name\"的函数。 覆盖率 pip install coverage coverage run --source=your_pacakge -m pytest coverage report -m 插件 Remote-SSH Microsoft 远程打开、编辑、运行代码库 Remote-SSH: Editing Configuration Files Microsoft Remote-WSL Microsoft 在windows上使用WSL vscode-icons VSCode Icons Team 优化VSCode图标 Format Files jbockle 批量format文件 GitLens Eric Amodio 显示提交记录；比对多个branch内容 Markdown Preview Enhanced Yiyi Wang markdownlint David Anson Python Microsoft Git Graph mhutchie Live Server Ritwick Dey 点击右下角的Go Live, 就能运行一个server，能在浏览器中浏览网页 可以配置默认打开的根目录 ssh服务器 安装Remote-SSH插件 点击左侧的远程连接图标(Remote Explorer), 左侧边栏右上角选择SSH TARGETS, 点击齿轮图标设置 编辑弹出的~/.ssh/config 有跳板机 Host jump_machine # arbitrary host name HostName jump.xx.xxxxxxxxx.com # url or ip address User xtwang # user name ForwardAgent yes Host remote_machine # arbitray name HostName 172.20.20.2 # url or ip address User xtwang ProxyCommand C:\\Windows\\System32\\OpenSSH\\ssh.exe -q -W %h:%p jump_machine # windows 下要写整个ssh的路径; # jump_machine为上一个entry的name 直连 Host arbitrary_name # arbitray name HostName xxxxx.xx.xxxx.xxx.xx # url or ip address User xtwang ForwardAgent yes Port 2190 + Host cdc190 HostName cdcgw.ie.cuhk.edu.hk User xtwang ForwardAgent yes Port 2190 将本地ssh公钥(~/.ssh/id_rsa.pub内容)加到服务器的authorized_keys(~/.ssh/authorized_keys)里. Copyright © Xintao all right reserved，powered by Gitbook修改时间: 2021-10-28 00:50:45 "},"工具软件使用/git配置.html":{"url":"工具软件使用/git配置.html","title":"git配置","keywords":"","body":"git配置 需求: 个人代码在github上，公司代码在gitlab上。在本地需要同时使用两个账号。关键是配置好各自的ssh公钥和远程关联。 配置glocal setting 根据使用频率，在github上使用global git setting，在gitlab上使用local的git setting。 可在任何目录下配置global setting。 git config --global user.name Xintao Wang git config --global user.email example@email.com git命令缩写 git config --global alias.st status git config --global alias.co checkout git config --global alias.ci commit git config --global alias.br branch git config --global alias.unstage 'reset HEAD' # 把暂存区的修改撤销掉（unstage） git config --global alias.last 'log -1' # 显示最后一次提交信息 git config --global alias.lg \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)%Creset' --abbrev-commit\" 如果只想在local文件夹生效，则把--global去掉即可。 生成公钥 github生成公钥 ssh-keygen -t rsa -C example@email.com 连续回车即可，默认文件为：id_rsa.pub. 把 id_rsa.pub 内容copy到github的setting SSH keys页面即可. gitlab生成公钥 ssh-keygen -t rsa -C gitlab_example@email.com 注意第一次生成id_rsa指定文件名：id_rsa_gitlab.pub. 把 id_rsa_gitlab.pub 内容copy到gitlab的setting SSH keys页面. 配置Cofing 用来区分git的时候，往哪个Host pull/push. 在.ssh/config写入以下内容: Host github.com HostName github.com User example@email.com IdentityFile ~/.ssh/id_rsa Host gitlab.xx.xxxxxxxxx.com HostName gitlab.xx.xxxxxxxxx.com User gitlab_example@email.com IdentityFile ~/.ssh/id_rsa_gitlab .ssh/目录下的known_hosts为免密登录用户信息，当成功添加github与gitlab的公钥，并向远程建立连接后，会自动生成known_hosts文件. 测试 ssh -T git@github.com ssh -T git@gitlab.xx.xxxxxxxxx.com 一般会显示：Hi xinntao or Welcom to GitLab, @xinntao. git clone 使用global setting的账号来git clone没有问题，下面主要说使用local setting的账号来git clone。 git clone git@gitlab.xx.xxxxxxxxx.com:yyy/zzz.git 它是根据git@gitlab.xx.xxxxxxxxx.com Host来识别使用哪个SSH key的 修改local git setting 进入clone下来的文件夹, 修改local git setting git config --local user.name wangxintao git config --local user.email gitlab_example@email.com 检查 .git/config: [core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true [remote \"origin\"] url = git@gitlab.xx.xxxxxxxxx.com:yyy/zzz.git fetch = +refs/heads/*:refs/remotes/origin/* [branch \"master\"] remote = origin merge = refs/heads/master [user] name = wangxintao email = gitlab_example@email.com [branch \"0.1.0\"] remote = origin merge = refs/heads/0.1.0 配置两个github账户 原理是一样的，创建公钥的时候区分开，然后在config里面写明: Host github.com-xintao HostName github.com User example_2@email.com IdentityFile ~/.ssh/id_rsa_work_xintao git clone的时候注意Host的后缀 git clone git@github.com-xintao:work_user1/repo_name.git Copyright © Xintao all right reserved，powered by Gitbook修改时间: 2021-10-28 00:50:45 "},"工具软件使用/git使用.html":{"url":"工具软件使用/git使用.html","title":"git使用","keywords":"","body":"git配置 清理过大的git repo 方法一(推荐): 使用bfg clone the bare repo (即带.git结尾的原始文件). git clone --mirror git@github.com:xinntao/BasicSR.git 删除大文件(>4M), 并改写历史. java -jar bfg.jar --strip-blobs-bigger-than 4M some-big-repo.git (BasicSR的repo中由于之前上传了.pth的model文件，导致整个repo很大=-=) 更新repo并上传. cd BasicSR.git git reflog expire --expire=now --all && git gc --prune=now --aggressive git push 经过更新后，BasicSR的repo大小由原来的40+M --> 1.4M :-) 方法二: 使用git filter-branch 参考 (我尝试了但没有成功，不知道哪里出了问题=-=) 自动同步Github到Gitee码云 Gitee是可以: 从Github的repo直接clone到Gitee; 手动强制从Github同步到Gitee. 但是没法在Gitee上设置定期自动从Github同步。 解决方法：使用Github的Actions - git-mirror-action repo下新建.github/workflows/gitee-repo-mirror.yml 写入: (这里以BasicSR为例) name: Mirror BasicSR to Gitee on: [ push, delete, create ] jobs: git-mirror: runs-on: ubuntu-latest steps: - uses: wearerequired/git-mirror-action@v1 env: SSH_PRIVATE_KEY: $ with: source-repo: 'git@github.com:xinntao/BasicSR.git' destination-repo: 'git@gitee.com:xinntao/BasicSR.git' 其中, SSH_PRIVATE_KEY: 1) Create a SSH key which has access to both repositories; 2) Store the private key as a secret. 这样，当我们push, delete, create便会触发Actions, 同步GitHub代码到Gitee. 参考: git-mirror-action 巧用Github Action同步代码到Gitee 码云gitee和github手动互相同步 因为国内github速度很慢，所以想使用码云gitee来做同步。但很多项目之前是放在github上的，所以希望能够在码云gitee和github之间同步起来。 从github同步项目 这步骤很简单，gitee支持从github项目直接导入 local代码同时push到github和gitee 一个本地仓库可以对应多个远程仓库。 将gitee加入远程仓库 git remote add gitee git@gitee.com:xinntao/records.git 可以通过git remote -v查看远程仓库： gitee git@gitee.com:xinntao/records.git (fetch) gitee git@gitee.com:xinntao/records.git (push) origin git@github.com:xinntao/records.git (fetch) origin git@github.com:xinntao/records.git (push) 可以看到本地仓库同时对应了github和gitee两个远程仓库。 push # push到origin: 对应github git push origin master # push到gitee git push gitee master [!TIP|label: 一次push到github和gitee] 添加新的远程仓库地址: 在.git的config, 添加URL, 比如: [remote \"origin\"] url = git@github.com:xinntao/BasicSR.git fetch = +refs/heads/*:refs/remotes/origin/* url = git@gitee.com:xinntao/BasicSR.git 这个解决方法有一个问题: 国内网不好, push到github的部分就卡住了=-= 个人主页同时放GitHub和Gitee Gitee可以参考：https://gitee.com/help/articles/4136 Github Public和Private同步 需求: 我有一个BasicSR的public repo, 同时，自己的private的开发是放在BasicSR-privaterepo的。希望定期(手动)可以从public的BasicSR repo pull. 在BasicSR-private中把public加入 git remote add pub git@github.com:xinntao/BasicSR.git 可以通过git remote -v查看远程仓库： origin git@github.com:xinntao/BasicSR-private.git (fetch) origin git@github.com:xinntao/BasicSR-private.git (push) pub git@github.com:xinntao/BasicSR.git (fetch) pub git@github.com:xinntao/BasicSR.git (push) pull 如果public repo有更新了，就可以pull到private repo中啦 git pull pub master Copyright © Xintao all right reserved，powered by Gitbook修改时间: 2021-10-28 00:50:45 "},"工具软件使用/Latex安装.html":{"url":"工具软件使用/Latex安装.html","title":"Latex安装","keywords":"","body":"Latex安装 Windows安装TeXstudio 安装TeX Live. 在 https://www.tug.org/texlive/acquire-netinstall.html 下载安装包install-tl-windows.exe. 这是在线安装包，如果速度慢，可下载镜像安装. (双击install-tl-windows.bat). 安装TeXstudio. 下载安装 https://www.texstudio.org/ Windows安装了texlive, texstudio 还是提示找不到texlive，那么需要在环境变量中添加路径，比如C:\\texlive\\2020\\bin\\win32 设置字典. 最新版有自带的字典, configuration里面的speeling选择应用的就行. Ref: http://www.cnblogs.com/joyeecheung/p/3596255.html Copyright © Xintao all right reserved，powered by Gitbook修改时间: 2021-10-28 00:50:45 "},"工具软件使用/gitbook使用.html":{"url":"工具软件使用/gitbook使用.html","title":"gitbook使用","keywords":"","body":"gitbook使用 安装 我是在Win10的wsl下安装使用的. 安装node.js和npm. Ref # Enable the NodeSource repository curl -sL https://deb.nodesource.com/setup_12.x | sudo -E bash - # install sudo apt install nodejs # verify node --version npm --version 安装gitbook # install sudo npm install -g gitbook-cli # verify gitbook -V 基本使用 初始化 gitbook init 它会生成 README.md: 本书介绍 SUMMARY.md: 定义本书目录 编辑 可用VSCode编辑 输出 输出静态网页 gitbook build 它会生成_book文件夹 输出pdf # install sudo apt install calibre npm install gitbook-pdf -g # 命令，会生成book.pdf的文件 gitbook pdf . 预览 gitbook --port 4000 serve ./ 可以在http://localhost:4000/实时预览 配置文件 在根目录下可以使用配置文件book.json. 更多内容可参见这里. 主题 gitbook可以修改主题，参考 Templating 和 Theming. Gitbook可以通过自定义插件来修改主题, 本主题是修改自theme-hqbook. 本主题取了名字叫coolx, 放在了github上. [!TIP|label: 使用private plugin] 在book.json中可以使用private的github repo作为插件, 语法为\"theme-coolx@git+https://github.com/xinntao/gitbook-plugin-theme-coolx\" 在修改主题时候，我们需要在本地调试插件: [!TIP|label: 在本地修改和调试插件] 在gitbook plugin folder, npm link 在gitbook folder, npm link gitbook-plugin-name Reference 另外一个使用了gitbook实现了sphinx主题的theme-veeam(但好像没有必要，直接用sphinx就好了=-=). 其他需求 (插件) 只要把插件写在book.json, 然后gitbook install, 就会自动安装用到的package, 不需要单独一个个安装. 自动生成目录（SUMMARY.md）Ref # install npm install -g gitbook-summary # cmd book sm 它会根据字母序来组织，如果需要保留顺序，可在题目前加上数字. 如果有多余的目录，比如\"node_modules\", 则可以在book.json中加入 \"ignores\": [ \"node_modules\" ] 折叠目录 使用插件: expandable-chapters. 需要配合插件 chapter-fold 一起用 折叠目录有一个缺点，就是默认是折叠的，这个没法默认展开，有点不友好. 页面添加修改时间等页脚 使用插件: tbfed-pagefooter. 支持中文搜索，及搜索结果高亮 使用插件: search-plus 使用Math Latex 使用插件: katex 字体颜色背景 使用插件: emphasize. 使用示例: This text is highlighted with markdown! This text is highlighted in red! This text is highlighted with a custom color! 源码: 把\\%替换成% This text is {\\% em \\%}highlighted with **markdown**!{\\% endem \\%} This text is {\\% em type=\"red\" \\%}highlighted in red!{\\% endem \\%} This text is {\\% em color=\"#ff0000\" \\%}highlighted with a custom color!{\\% endem \\%} 带颜色字体 红色字体示例. 红色字体 代码高亮 使用插件: prism. npm install gitbook-plugin-prism npm install gitbook-plugin-prism-themes 还需要配置pluginsConfig；禁用自带的-highlight. Prism Themes 添加TODO List 使用插件: todo 源码: - [ ] item 1 - [x] item 2 [ ] item 1 [x] item 2 查看修改源码 使用插件: editlink. 使用醒目的NOTE, TIP等 使用插件: flexible-alerts. [!NOTE] 源码 > [!NOTE] > Contents 支持修改显示的label: [!NOTE|label: 修改显示的label] > [!NOTE|label: 修改显示的label] > Contents TIP: [!TIP] > [!TIP] > Contents WARNING: [!WARNING] > [!WARNING] > Contents DANGER: [!DANGER] > [!DANGER] > Contents COMMENT: [!COMMENT] > [!COMMENT] > Contents 以下的功能暂时没有用，或在coolx主题中已经提供. 生成当前页的目录 使用插件: simple-page-toc 在需要生成目录的地方加上 . 添加Toc到侧边悬浮导航以及回到顶部按钮 使用插件: anchor-navigation-ex. 使用Google统计 使用插件: ga. 但目前版本好像不支持. References Gitbook 介绍: http://gitbook.zhangjikai.com/ https://tonydeng.github.io/gitbook-zh/gitbook-howtouse/index.html 更多插件推荐: http://www.unclealan.cn/index.php/front/153.html https://www.goodzzp.com/custom/plugin/other/index.html https://zhousiwei.gitee.io/2019/06/24/GitBook%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BC%98%E5%8C%96/ https://segmentfault.com/a/1190000019806829 Copyright © Xintao all right reserved，powered by Gitbook修改时间: 2021-10-28 00:50:45 "},"工具软件使用/Ubuntu安装MATLAB.html":{"url":"工具软件使用/Ubuntu安装MATLAB.html","title":"Ubuntu安装MATLAB","keywords":"","body":"Ubuntu安装MATLAB Ubuntu Silently Install MATLAB 若/usr/local空间不够, 可以安装在本地目录 /home/xtwang/MATLAB/R2017b. 挂载镜像文件/解压iso文件 mkdir /home/xtwang/tmp sudo mount -t auto -o loop R2017b_glnxa64.iso /home/xtwang/tmp [!TIP|label: 无法挂载] 如果遇到系统无法挂载的情况, 比如 failed to setup loop device: No such file or directory 采用 7z 进行iso解压 sudo apt-get install p7zip-full p7zip-rar # [On Debian/Ubuntu systems] sudo yum install p7zip p7zip-plugins # [On CentOS/RHEL systems] 7z x R2017b_glnxa64.iso -o/data/xintao/matlab 修改文件以便进行 Silent Install. 修改installer_input.txt和activate.ini. 修改installer_input.txt: destinationFolder=/home/xtwang/MATLAB/R2017b fileInstallationKey= (your key) agreeToLicense=yes outputFile=/home/xtwang/mathworks_xtwang.log mode=silent 修改文件 activate.ini: isSilent=true activateCommand=activateOffline #设置激活方式, 离线激活无需联网 安装 sudo install -inputFile /home/xtwang/installer_input.txt [!NOTE|label: 安装可能需要指定javadir] 如果只出现下面三行文字, 说明安装失败 Preparing installation files ... Installing ... Finished 原因: install文件只是一个shell脚本, 最终调用的是bin/glnxa64/install_unix, 并将参数传递给它. install_unix文件仍是shell脚本, 里面定义了丰富的参数及说明. 运行时加上verbose选项–v, 发现是javadir参数是空的. javadir一般在/usr/local/jdk/jre, 如果没有, 需要安装java. ./install -inputFile /data/xintao/matlab/installer_input.txt -javadir /usr/local/jdk/jre 注意使用绝对路径 激活 [!TIP|label: 如果有需要的话 :-|] sudo cp license_standalone.lic /home/xtwang/MATLAB/R2017b/licenses/ sudo cp libmwservices.so /home/xtwang/MATLAB/R2017b/bin/glnxa64/ 取消挂载 (可选)sudo umount -l /home/xtwang/tmp sudo rm -rf tmp 安装MATLAB的支持包 (可选)sudo apt-get install matlab-support 任意位置启动MATLABsudo ln -s /home/xtwang/MATLAB/R2017b/bin/glnxa64/MATLAB /usr/local/bin/matlab Copyright © Xintao all right reserved，powered by Gitbook修改时间: 2021-10-28 00:50:45 "},"流程规范与经验/":{"url":"流程规范与经验/","title":"流程规范与经验","keywords":"","body":"流程规范与经验 [!NOTE] 流程规范与经验 Copyright © Xintao all right reserved，powered by Gitbook修改时间: 2021-10-28 01:28:16 "},"流程规范与经验/01-概述与三个基本观念.html":{"url":"流程规范与经验/01-概述与三个基本观念.html","title":"01-概述与三个基本观念","keywords":"","body":"01 概述与三个基本观念 这个系列主要用来总结自己读 PhD 期间的一些经验。去年毕业之时就有这个想法，但一直没有写下来，因为有顾虑：一是说出来了感觉像鸡汤，有点食之无味弃之可惜的感觉；二是总结只是基于个人简单的感悟，怕有误导。 现在毕业一年多了，心态平和了，脸皮也厚了，觉得可以小结一下，反思过去的经验，自己也可以基于此去改进提高。我想对大家应该会有些帮助，至少增加了一个样本点。 为什么我觉得会有些帮助呢，特别是对刚进入这个领域的小伙伴，因为我自己的亲身体验。我刚开始读 PhD 的时候，完全是一颗小白菜，当时有很长的一段时间在原地打转，很多不合理的想法、做法带来了负面影响。甚至曾多次怀疑自己是否适合读博，是否能够顺利毕业。要是现在的我去告诉刚入学的我，那一定可以少走很多弯路，也可以走得更有信心。 比如， 当时的我，想法跳得很快，突然迸出来一个想法，就去尝试了；试了结果不好，就放弃了，就转而寻找下一个“机会”。那我现在就觉得这是“赌徒心态”，以赌徒心态做事，那就和赌徒一样，赌到最后一无所有了。比如，当时的我，跑实验没有章法，有什么想法就直接试，怎么管理代码呢？也不使用git，而是一个实验一个文件夹。这是落后的方式，就好像原始社会一样。不一而足。 我提这些我自身的经历，是想说明： 有时候我们可能不知道更好的方式，那么给予一个“种子”的想法，就是一个很大的帮助； 我们都是可以改变的，现在做得不好，做得混乱没有章法，但只要努力去改变，一个阶段后，就一定会有提升。 说到这里， 我必须要表达我对我的导师 Chen Change Loy (吕健勤)老师、董超师兄还有 MMLab 同学的感谢。在不顺利的阶段，耐心指导，积极鼓励，还有大家的互相交流，这些是最珍贵难得的。 在谈具体的之前， 我先聊聊三个基本观念。我觉得它们是最重要的几个点，有了它们，后面的内容就可以逐渐生发出来。 一、厨师最重要的品质 第一点是一个问题：要做一个好厨师，最重要的一点是什么？大家可以想想。 有人说刀工厨艺基本功要好；或者有好师傅带；或要有进取心；或要勤奋练习，持之以恒……我觉得啊，最重要的一点是会吃。他能够吃出一个菜好吃与否，好在哪里，差在哪里。如果一个厨师，自己做出了菜，不知道和大厨的差距，那他都不知道朝什么方向改进，总不能都靠着老师傅来教吧，而且再怎么教，也很难体悟到老师傅做菜的那种感觉。所以呢，能够看到自己的问题所在，知道和别人的差距在哪里，这是进步的前提，也最为关键了。只要知道了问题，就有办法去解决，去提升，去进步。 因此呢，老师师兄的几句话，实验室同学们的交流，往往提供了一个很好的切入点。我们习以为常的事，平时是很难觉察到差距，进而去改变。需要有一个契机让自己感受到问题所在，差距所在。这也是我觉得这一系列的文章有潜在帮助的原因。 另一方面则要培养这种“吃出差异”的自省能力，锻炼出敏感性，能够抓住差距的关键。 二、要有迭代的想法 大部分时候，我们做事都不是一蹴而就的，而是一步步提升的。迭代这个想法背后包含着几层意思： 我们有时候有完美主义，有不完美的地方就不想进行下一步，甚至不去做。如果这样，我们就被困在原地了。我们可以先有一个版本出来，不完美不要紧，后面可以继续提升嘛。 如果抱着迭代的想法，那我们便接受了现在的不足，接受不足，发现差距，是后面进步的起点。先抓住主要问题解决，在迭代中能更早地发现问题并解决，更早更灵活地进行调整。 有了迭代的想法，就不会抱着“试一把”的心态，是在踏实做事，心里不虚，对后面的发展也会越来越有信心。 相反地，不这样做，想着一蹴而就，一发即中，那便是赌徒心态了。一旦有赌徒心态了，很多细节也就不关注了，只想着中彩票。那么，出了问题，就不知道是实现上的问题呢，还是想法本身有问题，长期以往，就打击自信心了。 三、是自己的想法，是自己的事 不知道大家有没有这样的感受：如果一个想法是老师给的，试了一下或者几下，不work，心里便会犯嘀咕，是不是老师的想法有问题啊，便归因到外部去了。相反地，如果是自己的想法，特别是花了一段时间思考得到的想法，不work了，也会有一股子犟劲，“怎么会不work呢？是不是哪里实现有问题啊”。“这个想法我想了那么久，看起来很合理，怎么就不work呢？” 这便是问题的关键。很多时候，做出来，做不出来，就在一念之间。再多想一下，再多做一点，可能就带来很不一样的结果了。因此呢，我们要把想法当作是自己的想法，要把事情当做是自己的事。而实际上，它们也的确是自己的想法，也的确是自己的事。有时候我们不注意，因为很多事情是发生在潜意识里面的。我们便要格外注意，需要的时候要反观自己的潜意识了。 额外说一句，我觉得高明的老师或者指导，就是要通过某种方式，把指导转变成让学生以为是自己发现了问题，以为是自己有了想法，以为是自己得到了提升。这样的教导是最高明的。 以上便是我觉得很重要的三个基本观念，如果还有的话，可能就还有半个观念——要有平常心，不偏执。很多时候，确实付出了努力，但是外在的所得，在和别人相比之下，觉得多了或者少了，心里不平衡了。这样的事很正常，因为还有很多很多的因素影响着事物的发展，不止是个人的努力。如果我们没有平常心对待，“偏要什么什么”，“偏得怎样怎样”，便会偏执。一旦偏执，自己的节奏会乱了，想法做法便会混乱，赌徒心态便会滋生，反而影响自己，不自在。特别是最近各种资讯都在贩卖焦虑的时候，更需要平常心，有定力。 接着，我们回到系列的题目【流程规范与经验】。我们谈一下目的。目的用下面一张PPT就可以说明啦，就不具体解释了。 最后，这个系列大概会按照下面的提纲来写： 朴素的总结 开发流程 开发环境 代码规范 代码管理 项目（实验）管理 汇报讨论 开源共享 希望对大家有所帮助 :-) Copyright © Xintao all right reserved，powered by Gitbook修改时间: 2021-10-30 11:30:08 "},"流程规范与经验/02-朴素的总结.html":{"url":"流程规范与经验/02-朴素的总结.html","title":"02-朴素的总结","keywords":"","body":"02 朴素的总结 首先，来谈谈一些朴素的总结。“朴素”的意思是：这些是自己在日常中自发总结的，还没有经过系统化、理论化的思考，还不是一个成体系的经验。下面的总结会有些琐碎，我一点点说明。这些总结更多描述的是思想性的东西，我们不是要拘泥于所描述的内容，而是要有类似的意识去看待我们平时的状态。我自己是受益于这些简单的总结的。 “要多想”，“这合理吗？这不合理” 这是引用的两句话，我会经常记起来： “要多想”：是《三体》中章北海的父亲与章北海的重要对话。 父亲：要多想。 章北海：想了以后呢？ 父亲：北海，我只能告诉你在那以前要多想。 我是借用章北海父亲的话，想表达“要多想”本身的这个含义。无论是研究上的想法，还是实验的设计与分析。我们都要多想，想什么呢？比如： 有没有 没有考虑到的点 有没有 更好的方式，是否是必须的 该如何取舍 想清楚了、想全面了，再动手，往往会事半功倍，所谓磨刀不误砍柴工。 “这合理吗？这不合理”：这是一句网络上的梗，比较好地传达了需要不断反思自己、反思自己的想法的意思。 我们要时刻基于经验，基于常识判断，多反问自己一句“这合理吗？”。一般来说， 不合理 意味着 bug 或者 新发现；比如实验结果与分析的不合理 不合理 意味着 需要改变：比如有些代码、流程太麻烦，要思考更优的代码、流程，提高效率 这样多思考和多反思，是可以锻炼的，以达到潜意识就可以做的地步。此外，我们需要保持足够的敏感，看到不合理的地方，不能无动于衷。 要可大可小 做研究、写paper要关注的东西是非常多的，我们需要有一个能力，能够“可大可小”地来看问题，在不同的尺度上看问题。 大要抓住宏观 一个研究项目，我们要把握住大的宏观方面，比如 项目整体的目标，框架，方案 研究(paper)的贡献；paper的布局；研究项目整体安排 做实验的 RoadMap，排期 虽然在研究进行的过程中，会有新的变数，需要我们不断根据情况实时调整，但这不妨碍我们不断地去抓宏观。并且，往往这些宏观方面应该要稳定发展，宏观变得太快，也是不合理的。 抓住宏观，我们同时要注意到： 要抓主要矛盾，不能拘泥细节，特别是可有可无的细节，否则会落入“细节的黑洞” 防止钻死胡同，越走越偏 掉入细节的黑洞，会导致不断发散。我们未知的东西是无穷无尽的，如果这样发散下去，就没有办法收敛出阶段性的结果来了。并且，如果每个细节都当成了重点，那反而是没有重点了。因此，我们要培养能力：能够抓住主要矛盾，着重关注他们。话又说回来，上面说的这些又有可能会被误解，误解为不需要关注细节。不是这样的，我们是要关注细节，但又不能拘泥于细节。现在的很多代码、实验，work 不 work 很多都在细节上的。如果不关注细节，结果也搞不出来。这些便是重要的细节。因此，总结一下是：1) 要会抓住主要矛盾的细节；2) 不拘泥于细节。 另外一个常见的问题是，如果没有一个宏观的东西框住我们的想法（比如项目整体的目标，框架，方案 或者 项目整体安排 或者 实验的 RoadMap，排期），我们做着做着，就会走偏了，甚至脚踩西瓜皮，滑到哪里算哪里。抓宏观，便可以很好地防止这样的问题，时刻问问自己最近在做啥，和大目标有啥关系。这也算是“不忘初心”吧。研究中确实还有一类是，不可规划的研究。比如突然发现了有趣的现象，然后找到了有趣的结论。这类算是研究中的惊喜时刻了。我们讲要抓宏观，不是说要掐灭这类想法。他们并不矛盾的。 小要做好细节 研究中的细节也是非常多的，比如： 项目方案的细节 研究(paper)的细节，比如怎么描述、逻辑上是否讲得通的细节 实验的细节，代码的细节 细节很重要：方案是否实现得了，实验能不能做出来，细节很重要。实际中，我们要有足够的耐心去分析细节；要保持对细节其他可能性的空间，等等。 如何把握大和小的尺度 同时做到大和小是有挑战的。一个好的类比，把自己想成一只大鸟，从天上俯瞰地面，我们既要飞得够高，看到地下的全貌（有时还被云遮挡了）；又能够俯冲下来，贴近地面，看到具体的地面的细节。我们要做到可大可小，就是这只大鸟一会儿爬升，一会儿俯冲，在不断地切换。做到这件事情本身，或许也不那么容易： 需要依赖于经验 要有敏感性：什么时候该宏观看问题了，什么该看细节了；细节要关注哪些 还是要多想 是正确的趋势吗 这块可能是会有争议的。因为一般来说，技术发展有其客观的规律，一旦涉及到对错，就会加入价值判断了。这里想表达的观点是：我们要关注技术未来的发展。一方面，新的技术会带来新的变革，我们要积极关注新技术的发展；另一方面，我们最好是研究未来的技术，无论是短期的未来还是长期的未来。 当我们回过头去看技术的发展的时候，我们会看到：技术是有发展方向的，是往着更好的方向发展的。 如果我们站在现在的角度看，那就要尽量往正确的发展方向去思考。提出的方法，所作的探究是否在这个发展方向之上。这里并不是说要限制住技术只能有一个路径。技术有各式各样的发展路径，这里的发展方向更多指的是宏观的一个趋势。 我们也可以假想站在未来的角度（五年之后，十年之后），回过头来看，目前所做的这个工作是否有必要、有价值；它是否反而阻碍了技术的进步。这样想的话，能够更好地帮助我们理解所做工作的价值和意义。 研究要分清四个方面 研究中，我们要时刻明白自己处于哪个阶段，特别是对于刚入门的同学。如果不清楚，研究会很难进行下去。 比如，刚入门的同学，在讨论汇报的时候，往往会说，他过去的一段时间尝试了这个那个，分别得到了什么结果（当然大部分是不太好的结果），然后就没有了，似乎在等着对方给他分析和确定下一步的行动步骤。这样就不对了，因为我们不是机器，输入指令，输出结果，然后等着下一个指令。有了实验的结果，更重要的是分析；不好的结果也不是坏事，面对不好的结果，希望有一个分析：为什么结果和我们想的不同；怎么说服自己这个结果是客观的结果，而不是实现的问题，调参的问题等等；有没有一些“探测的手段”能够旁证。在讨论的时候，我们是想针对这些初步分析，进一步的分析和讨论。而不是抛出一个结果，其他都不关我事的感觉。 这四个方面是： Assumption. 我们有idea或跑实验之前，一定是会有假设的，只是很多时候我们没有意识到。我们有一个想法时，希望它在 xxx 任务上会 work，这背后会有一个假定它 work 的逻辑/story，以用来说服自己为什么它会 work。（不然，你自己都不坚信这个 idea，凭啥会去尝试呢）。我们分析得更多，便会更加清楚：这个假定它 work 的一套逻辑/story中，又会有很多其他的假定和依赖。我们对这些假定理解的越多，当出现不好结果的时候，便能够更好推测问题出在哪里，有什么应对方法来定位问题，解决问题。 Expectation. 预期是和假定很相关的。当我们有假定的时候，一定也包含了预期的结果。比如，有一个 idea，便会有预期的结果；有一个假定它 work 的逻辑/story的时候，我们便会预期它会呈现怎样的状态，有什么可以预期观察的现象来说明确实是按照我设想的逻辑/story运行的。甚至，当我们跑一个实验的时候，一定也会有了对他的预期：结果和中间的呈现。那无论后面是符合预期的，还是不符合预期的，我们其实都可以分析了。 Observation. 观察是当我们跑了实验之后，对实验结果的一个整理。有时候结果会繁杂，我们需要从不同的维度，理出几条观察的线，以便我们更好地分析。很多时候，我们跑完实验止于此了，那么就形成不了一个闭环，进而不能在认识上有一个提高。 Analysis. 分析是需要对实验的结果（Observation）有一个更深刻的理解，进而修正我们的假设与预期，进行下一步的实验与验证。结合之前的预期，我们可以分析：如果符合预期，那么是否按照预期的逻辑/story产生的这个结果；如果不符合预期，为什么不符合，是我之前提出假设和预期的时候忽略了什么，还是缺少了相关的认识和经验，修正之后的解释是否能够说服自己这个结果不是bug或者调参的问题，而是客观的结果。总的来说，分析是形成闭环的关键一环，它必然有所得：是我们哪里忽略了，没有认识到；或者下一步该如何行动。 我们应能够时刻反观自己的想法，是处于哪个阶段中。 作为研究，我们的任务是要有更多的Assumption，然后得到验证，或者 insights；我们的任务不是止于Observation， 而要有Analysis，形成一个闭环，螺旋式上升。 什么时候该改进了？ 正如前面说的，我们要有迭代的思想。那什么时候该改进了呢？ 总的说来，需要敏感一些，如果一些流程、方案让自己感觉不爽了，比如很麻烦，或者很重复，或者并不优美，这时候就要考虑去改进了。 就我自己而言，BasicSR 就是这样在一步步的改进中进化而来的。自己跑实验遇到麻烦的地方，不爽了，就想着要添加一个新功能，或者改进现有功能。另外的例子，比如，研究中经常要查看和比较图片的视觉效果，现有的方案没有很好地解决这个问题，就慢慢开发了 HandyView。再后来，做人脸相关任务的时候，发现 detection, alignment, parsing 这些是基础功能，每次都要重复调用，也不确定哪个方案是目前最优的，很麻烦，也很重复。就想着改进，把这些功能单独出来，形成了 facexlib。当然更多的是平时的代码和脚本中体现出来的。总的说来，我们要有改进的意识，并且要足够敏感。该懒惰的地方要懒惰一些，懒惰才推动着让我们开发更好的（自动化的）流程。 时间相关 合理安排时间 我们要做的事情很多，想idea，论文阅读，代码实现，跑实验，维护实验，整理结果，分析总结等等。有些是有依赖的，有些是相对独立的。我们要把这些非线性的事情安排放进线性的时间里面，这就要合理安排时间了。 它本质上是一个小学生的题目： 小明帮妈妈做饭。淘米：3分钟，煮饭：25分钟，洗菜：8分钟，切菜：5分钟，炒菜：10分钟。请问小明怎么安排，才能使得做完这些事所花费的时间最少？ 我们要自己排出一个甲乙丙丁的优先级来。 微处理器流水线 我们实验有一个特点，需要等待 程序在GPU上跑完，少则一两天，动则三四天，甚至一周。如果我们每次都等到实验结束，然后再分析，有了反馈再改进实验，再进行下一轮的实验，那项目的周期就被大大拉长了。一个月也跑不了几轮实验。这个问题的解决方法，就是要参考微处理器流水线的方案。 我们可以类比过来，一个时钟周期就是一天。四个执行阶段，对应 假设（想法，阅读论文），预期（实验设计，代码实现），观察（跑实验，出结果）和 分析。那么，最理想的情况是每天都有新的实验跑上，每天都有可分析的实验结果，得到好的结果或者insights。这样就大大缩短了项目的周期。当然这是很理想的情况，因为实际上并不能那么精准的安排；有些实验也有前后依赖。但总的思想应该是仿照微处理器流水线的方式。 我们的时间 = 我们的时间 + 机器的时间 这个是之前打比赛总结的一句话。这个和我们的研究方式密切相关。我们很大程度上是在不断尝试，等机器的结果。 机器所需的时间是不可压缩的。如果我们合理安排，让实验先跑起来了，然后我们再休息，这时候机器在跑。从某个角度来说，我们的有效时间就变多啦。 这个特性也导致，会越睡越晚=-= 因此晚睡变成了必然的结果... 空间换时间 这个其实已经隐含在 合理安排时间 和 微处理器流水线 中了。 因为我们的实验都会有依赖，所以有时候并不能简单地并行处理。这时候，就可以根据现有的资源情况，在时间和资源（空间）上取一个平衡。比如，我们有三组实验 A, B 和 C。 他们是有依赖的，B 依赖于 A， C依赖于B。A有两种变体，B有三种变体，C有两种变体，我们是希望找到最有效的一组setting （比方说 A1-B3-C2）。 一种做法是先跑A1和A2，确定哪个最好。然后基于此，再跑B组实验，最后跑C组实验。这样的话，需要跑 2+3+2=7组实验，需要三个实验周期。 如果我们资源够多的话，可以直接把 2x3x2=12组实验都跑上，只需要一个实验周期就可以了。这样就是极致的空间换时间了。 但是呢，我们往往是在资源和时间上取一个平衡，所以不会所有的组合都跑。一般来说，我们自己会有预期，比如A1成功的概率更大，那么设计实验的时候，就把概率大的组合先跑上。如果恰如预期的这样，就类似于流水线处理中的 hit 了。 这是一个理想的情况，实际的情况会比这个更加复杂，就需要灵活处理，平衡资源和实验周期了。 情绪影响 人不是机器，会受到情绪很大的影响，这个影响甚至会影响我们的理性判断。 不知道大家有没有这个感受，比如当我们对实验不好的结果很消极的时候，“心态崩了”。这个时候，再去看结果，越看结果越差，特别是看主观结果的时候。我们的记忆就只记住那些不好的方面，好的方面被潜意识忽略了，进而得出很不客观的结论。 当我们情绪不好的时候，我们也常常会几个小时在电脑前，看似在分析结果，但猛地一回头，会意识到这几个小时，啥进展也没有。我自己会有这样的感受。这就是被情绪支配了。 那当遇到这样的情况，首先要自己意识到自己是被情绪影响了，这时候，再在座位上看着电脑已然没有什么意义了，这个时候，不如到户外走走，吹吹风，调整一下，清醒一下。然后再回来处理，反而是更加有效率的。往往这时候，也不会被困在一个想法或者情绪里面，反而思路能够更加开阔。 先进去 我们也会遇到不想“碰”的状况，这时候可能是由于要做的东西太复杂，或者是因为就是莫名的情绪抵触。 这时候，我自己的经验是 先不管那么多，先“无脑”（或者硬着头皮）地进去再说。往往一旦静下心来去做了，发现不像自己想的那样的，抵触的情绪便也消除了大半。 如果要做的东西复杂，可以慢慢先拆解一下，或者就先做一下它外围的杂事，做着做着便会摸到思路了。 这其实也是由于我们的“误判”，而这种误判也是由于被情绪、感受影响了。所以呢，我们也要尝试反观一下，哪些是情绪、感受的因素，有时候它们不见得是你自己的想法，而是被外界影响的。 赌徒心态 赌徒心态，这个在概述里面有提过。 有时候就想尝试一把，试了结果不好，就放弃了，就转而寻找下一个“机会”。 这样的赌徒心态，只适合摘取“low hanging fruit”，那现在深度学习发展得那么久了，这样的fruits 基本已经没有了。 有想法了，试一下是 OK的，但是至少要想明白为啥觉得它能够 work (假设)，预期是怎么的表现。然后结果不好，至少需要分析一下，要给自己信服的理由，说明为啥它不work。 另外一方面，赌徒心态，不是在想做好一件事本身，而是朝着成果在走。更好的方式是 想着把一件事做好，那么就会一步步踏实去做，会不断地去迭代。也会自然地关注到做好这个事情的方方面面的细节，有不合理的，不对的地方便会去改进。当把这些细节都做好了，有时候“你要赌”的那个东西才可能被搞出来。 就像突破我们想法的新的技术，比如最近的 Vision Transformer, MLP-Mixer这些，绝对不是赌徒心态搞出来的。它们那么难调，都能够被调出来。要是赌徒心态的话，搞一把，（肯定不work），然后就放弃了=-= 那么，到底是什么推动着他们能够做出这样的工作呢？—— 应该是一个 “它一定会 work” 的信念。这种信念可能来自于他们的经验，对已有工作的观察等等。（我也很好奇他们的研究过程，希望他们能够写一个经验分享帖子 :-)） 坚持做一件事 我们处在一个较好的领域，算是历史的大势了。 那只要坚持做，总会有成绩。所谓“积跬步，至千里”，所谓“久久为功”。 之前看过戴建业老师悼念袁隆平院士的视频《悼念袁隆平院士最好的方法就是向他学习！》。视频里面提到了戴建业老师从袁老身上学到的：我们一个普通的人，把全部的精力集中在干一件事情上，我们一定会把一件事干好。比如袁老就一直研究水稻，戴老师一直研究诗词。这种精神和做法我觉得是值得深思和学习的。 也推荐大家看看~ https://www.bilibili.com/video/BV1ov411G7He Copyright © Xintao all right reserved，powered by Gitbook修改时间: 2021-11-01 02:21:18 "},"流程规范与经验/03-开发流程.html":{"url":"流程规范与经验/03-开发流程.html","title":"03-开发流程","keywords":"","body":"03 开发流程 Copyright © Xintao all right reserved，powered by Gitbook修改时间: 2021-11-02 00:48:11 "},"流程规范与经验/10-文献格式与管理.html":{"url":"流程规范与经验/10-文献格式与管理.html","title":"10-文献格式与管理","keywords":"","body":"10 文献格式与管理 文献格式 我们写作用LaTex，对应的文献格式就是bib了。我们关注两个方面：一个是在论文中呈现出来的引用形式；另一个是引用的bib格式。 Kaiming文章的每个细节都做得很细致，我们从他最近一作的文章中摘取几个典型的样例。（样例从这两篇文章中来：MAE, MoCo） 会议 Conference 会议的Workshops 杂志 Journal arXiv 网页 添加额外信息 我们引用的类别基本也就上面这些。我们可以看到： 作者名字是全名（这个目前CVPR/ICCV/ECCV的templates就会给出全名） 标题：只有句首字母大写，除非特定的单词（这个templates会自动处理，如果需要自定义大小写，在bib中需要加'{ }'） 会议/杂志/arXiv的名称，很简洁，主要采用了缩写（也可以采用全称，但需要保持一致）。没有卷数、页数这些额外的信息 其他会添加更加细致的信息，比如访问的版本，是否从supplementary中引用了结果，对于重要的还提供了访问时间 如果同时有发表的版本（会议/杂志）和arXiv的版本，尽可能引用其发表的版本 我们就向大佬学习。由于在arXiv的源码中看不到原始的bib文件，我就按照自己的理解，给出一个bib的方式。我们在后面的文献管理便可以基于这个格式来做了。 下面提供了复现的效果以及bib源码，完整的bib样例文件可以：  example.bib 网页查看   example.bib 下载  会议 Conference @inproceedings{chen2021SimSiam, title={Exploring simple {S}iamese representation learning}, author={Chen, Xinlei and He, Kaiming}, booktitle=cvpr, year={2021} } @inproceedings{hinton1994autoencoders, title={Autoencoders, minimum description length, and helmholtz free energy}, author={Hinton, Geoffrey E and Zemel, Richard S}, booktitle=nips, year={1994} } 会议的Workshops @inproceedings{cubuk2019randaugment, title={RandAugment: Practical automated data augmentation with a reduced search space}, author={Cubuk, Ekin D and Zoph, Barret and Shlens, Jonathon and Le, Quoc V}, booktitle=cvprw, year={2020} } 杂志 Journal @article{becker1992self, title={Self-organizing neural network that discovers surfaces in random-dot stereograms}, author={Becker, Suzanna and Hinton, Geoffrey E}, journal={Nature}, year={1992} } @article{chen2017deeplab, title={Deep{L}ab: Semantic image segmentation with deep convolutional nets, atrous convolution, and fully connected {CRFs}}, author={Chen, Liang-Chieh and Papandreou, George and Kokkinos, Iasonas and Murphy, Kevin and Yuille, Alan L}, journal=pami, year={2017} } arXiv @article{ba2016layer, title={Layer normalization}, author={Ba, Jimmy Lei and Kiros, Jamie Ryan and Hinton, Geoffrey E}, journal={arXiv:1607.06450}, year={2016} } 网页资源 @misc{wu2019detectron2, author={Yuxin Wu and Alexander Kirillov and Francisco Massa and Wan-Yen Lo and Ross Girshick}, title={Detectron2}, howpublished={\\url{https://github.com/facebookresearch/detectron2}}, year={2019} } 添加额外信息 @article{tian2019contrastive, title={Contrastive multiview coding}, author={Tian, Yonglong and Krishnan, Dilip and Isola, Phillip}, journal={arXiv:1906.05849}, year={2019}, note={Updated version accessed at \\url{https://openreview.net/pdf?id=BkgStySKPB}} } @inproceedings{zhuang2019local, title={Local aggregation for unsupervised learning of visual embeddings}, author={Zhuang, Chengxu and Zhai, Alex Lin and Yamins, Daniel}, booktitle=iccv, year={2019}, note={Additional results accessed from supplementary materials} } @article{bao2021beit, title={ {BEiT}: {BERT} Pre-Training of Image Transformers}, author={Bao, Hangbo and Dong, Li and Wei, Furu}, journal={arXiv:2106.08254}, year={2021}, note={\\emph{Accessed in June 2021}} } 我们主要用了 inproceeding 和 article 两个类别，更多的类别和字段可以参考 BibTEX Entry and Field Types. 清理 bib 文件 一般在写作完成后，我们会清理bib文件，使得其符合上面说的要求。 对 *.bib 文件的清理有很多重复的动作，因此写了一个方便的 python 脚本， 在HandyLatex上。它可以用来处理大部分的场景。当然，它不完美，很多时候还需要人为介入。 文献管理 写作需要bib entry，平时也需要文献管理。最好的方式是将两者结合起来，减少重复劳动。 我们对文献管理主要有以下几个需求： 方便组织、标记文章 能够方便打开pdf，有时候需要做标注，能够做到多设备同步 写作的时候，能够方便导出 bib entry。 在满足上面需求的情况下，我们希望这个软件越简单越好。这里推荐使用 JabRef，小巧、简单易用，是我导师推荐的。JabRef的特点是： 它本质上就是管理一个bib文件，因此文件很小巧，而且其他编辑器也可以打开 它不存储pdf，它只是做了一个到pdf文件的链接 如何做到多设备同步呢，可以使用其他的自动同步。比如我使用 OneDrive, 同步很快，和 Windows 系统衔接得很好 写作时候，可以直接 copy 里面得 bib entry就可以拿来用了。 它的界面以及主要用的功能如下图： 我一般在平时往库里添加bib entry的时候，把它关键的几个field都clean一下。 其中 booktitle 或者 journal 这个字段，我使用 bib string，在 JabRef 中会使用井号包含起来，比如 #cvpr#。它们在bib中可以被定义好的 shortname 或者longname 替换的。比如： @String(PAMI = {IEEE TPAMI}) @String(IJCV = {IJCV}) @String(CVPR = {CVPR}) @String(CVPRW = {CVPR Workshops}) @String(ICCV = {ICCV}) @String(ICCVW = {ICCV Workshops}) @String(ECCV = {ECCV}) @String(ECCVW = {ECCV Workshops}) @String(NIPS = {NeurIPS}) @String(ICPR = {ICPR}) @String(BMVC = {BMVC}) @String(TOG = {ACM TOG}) @String(TIP = {IEEE TIP}) @String(TVCG = {IEEE TVCG}) @String(TCSVT = {IEEE TCSVT}) @String(TMM = {IEEE TMM}) @String(ACMMM = {ACM MM}) @String(ICME = {ICME}) @String(ICASSP= {ICASSP}) @String(ICIP = {ICIP}) @String(ACCV = {ACCV}) @String(ICLR = {ICLR}) @String(IJCAI = {IJCAI}) @String(PR = {PR}) @String(AAAI = {AAAI}) @String(CSVT = {IEEE TCSVT}) @String(ICML = {ICML}) 基本就是这些啦~ Copyright © Xintao all right reserved，powered by Gitbook修改时间: 2021-11-22 22:22:11 "}}